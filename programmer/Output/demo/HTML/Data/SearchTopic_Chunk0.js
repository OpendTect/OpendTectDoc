define({"0":{y:0,u:"../content/html_front_page/od_progman_v6.htm",l:-1,t:"OpendTect Programmer\u0027s Manual - 6.6",i:0.0161290322580645,a:"Copyright © 2002-2020 by dGB Beheer B.V. All rights reserved. No part of this publication may be reproduced and/or published by print, photo print, microfilm or any other means without the written consent of dGB Beheer B.V. Under the terms and conditions of any of the following three license types, ..."},"1":{y:0,u:"../content/1_preface.htm",l:-1,t:"1 Preface",i:0.0161290322580645,a:"1 Preface"},"2":{y:0,u:"../content/1_preface/1_1_about_this_manual.htm",l:-1,t:"1.1 About this Manual",i:0.0161290322580645,a:"This is the manual for developers wanting to use, change or contribute to the source code of OpendTect. It describes all necessary steps taken to download and compile OpendTect from source on Windows, Linux and Mac OS. There is also a separate section for those who want to develop plugins, as it is ..."},"3":{y:0,u:"../content/1_preface/1_2_release_notes.htm",l:-1,t:"1.2 Release Notes",i:0.0161290322580645,a:"This is the programmer documentation for release OpendTect v6.6- an open source post-processing, and seismic interpretation system created by  dGB Earth Sciences . OpendTect is released via the internet. Users can download the software from the  dGB website . It will run without license protection. ..."},"4":{y:0,u:"../content/1_preface/1_3_about_opendtect.htm",l:-1,t:"1.3 About OpendTect",i:0.0161290322580645,a:"OpendTect is a free, open source seismic interpretation system and software development platform. The system supports all tools needed for visualizing, analyzing and interpreting 2D, 3D and 4D seismic and Geo_Radar data. The software is written in C++ and the same codebase compiles and runs on ..."},"5":{y:0,u:"../content/1_preface/1_4_copyright.htm",l:-1,t:"1.4 Copyright",i:0.0161290322580645,a:"The information contained in this manual and the accompanying software programs are copyrighted and all rights reserved by  dGB Beheer BV, hereinafter dGB. dGB reserves the right to make periodic modifications to this product without obligation to notify any person or entity of such revision. ..."},"6":{y:0,u:"../content/1_preface/1_5_acknowledgements.htm",l:-1,t:"1.5 Acknowledgements",i:0.0161290322580645,a:"The OpendTect system is developed around concepts and ideas originating from a long-term collaboration between dGB and Statoil. Most of the system was and is developed through sponsored projects. We are indebted to all past, present and future sponsors. To name a few: Addax ARKCLS BG Group Chevron ..."},"7":{y:0,u:"../content/2_build_a_standalone_plugin.htm",l:-1,t:"2 Build a standalone plugin",i:0.0161290322580645,a:"2 Build a standalone plugin"},"8":{y:0,u:"../content/2_build_a_standalone_plugin/2_1_introduction.htm",l:-1,t:"2.1 Introduction to building a stand alone plugin",i:0.0161290322580645,a:"Making your own software within OpendTect is in principle pretty easy. You could change the software by modifying existing classes and functions, and adding your own stuff to the libs. The advantage is total control. The problem with this approach, however, is that you have to keep the OpendTect ..."},"9":{y:0,u:"../content/2_build_a_standalone_plugin/2_2_setting_up_the_environment.htm",l:-1,t:"2.2 Setting up the Environment",i:0.0161290322580645,a:"For setting up OpendTect to be able to build and test your own plugins; download the installation manager at  download.opendtect.org  or go to Utilities/Installation/Update in the main menu if OpendTect is already installed. This will open the OpendTect Installation Manager. In the installation ..."},"10":{y:0,u:"../content/2_build_a_standalone_plugin/2_3_building_the_tutorial_plugin.htm",l:-1,t:"2.3 Building the Tutorial Plugin",i:0.0161290322580645,a:"After creating the folder, run CMake and select the WORK directory you just created, put the location in both the \"source\" and \"output\" fields. Then press the \u0027Configure\u0027 button Select Visual Studio 15 2017 as the generator and choose x64 as the platform. Click Finish. The first configuration will ..."},"11":{y:0,u:"../content/2_build_a_standalone_plugin/2_4_debugging_your_plugin.htm",l:-1,t:"2.4 Debugging your plugin",i:0.0161290322580645,a:"2.4 Debugging your plugin"},"12":{y:0,u:"../content/2_build_a_standalone_plugin/2_5_creating_the_help_documentation.htm",l:-1,t:"2.5 Creating the Help documentation",i:0.0161290322580645,a:"Like any other commercial application, our plugin also needs a help document which a user can see by clicking on a button in the user interface. The OpendTect help system is quite flexible and allows a plugin to define its own way of showing help information. But in most cases, all you want is to ..."},"13":{y:0,u:"../content/2_build_a_standalone_plugin/2_6_installation_and_auto-loading.htm",l:-1,t:"2.6 Installation and auto-loading",i:0.0161290322580645,a:"2.6 Installation and auto-loading Once you have made your own plugin, you probably would like it to be loaded automatically whenever OpendTect is started. OpendTect provides some facilities that do just that."},"14":{y:0,u:"../content/2_build_a_standalone_plugin/2_6_installation_and_auto-loading/2_6_1_preparing_a_plugin_for_auto-load.htm",l:-1,t:"2.6.1 Preparing a plugin for auto-load",i:0.0161290322580645,a:"#include \"odplugin.h\" is needed for the PluginInfo structure and the PI_AUTO_INIT_xxx defines. The GetxxxxPluginType() specifies when a plugin is loaded: •\tPI_AUTO_INIT_EARLY : Plugin is loaded before construction of main window •\tPI_AUTO_INIT_LATE : Plugin is loaded after construction of main ..."},"15":{y:0,u:"../content/2_build_a_standalone_plugin/2_6_installation_and_auto-loading/2_6_2_installing_plugins_for_auto-load.htm",l:-1,t:"2.6.2 Installing plugins for auto-load",i:0.0161290322580645,a:"The auto-load tool of OpendTect looks for plugins to load in two places: 1) Where are the .ALO files stored? The two locations searched are (in this order): •\t\u003cuserdir\u003e/plugins/\u003cplatform_dir\u003e •\t\u003csystemdir\u003e/plugins/\u003cplatform_dir\u003e 2) Where are the plugin libraries? Locations are: ..."},"16":{y:0,u:"../content/2_build_a_standalone_plugin/2_6_installation_and_auto-loading/2_6_3_using_alo_files.htm",l:-1,t:"2.6.3 Using .alo files",i:0.0161290322580645,a:"Auto Load files are simple text files that tell a program which plugins it is supposed to load from the \u0027libs\u0027 directory. Since OpendTect contains multiple programs, each program has its own set of .alo files \u0027\u003cprogram name\u003e.*.alo\u0027, while the plugins can be shared between multiple programs. ..."},"17":{y:0,u:"../content/2_build_a_standalone_plugin/2_7_distributing_your_plugin.htm",l:-1,t:"2.7 Distributing your plugin",i:0.0161290322580645,a:"The publishing and distribution of OpendTect plugins is pretty straightforward. The .alo files can be installed in the plugins/platform ($DTECT_APPL/plugins/$HDIR) directory, while the actual plugins (the .DLL, .so or .dylib files) go in the normal bin sub-directory. On Unix, this means that you can ..."},"18":{y:0,u:"../content/3_the_tutorial_plugin.htm",l:-1,t:"3 The Tutorial Plugin",i:0.0161290322580645,a:"3 The Tutorial Plugin"},"19":{y:0,u:"../content/3_the_tutorial_plugin/3_1_introduction.htm",l:-1,t:"3.1 Introduction",i:0.0161290322580645,a:"We have created the Tutorial plugins that you can find in your work environment. As is common in OpendTect, there is a plugin \u0027Tut\u0027 for non-ui, real-work stuff, and the \u0027uiTut\u0027 for the GUI part. The idea of the tutorial plugins is to show a variety of common things that one might want to do, rather ..."},"20":{y:0,u:"../content/3_the_tutorial_plugin/3_2_uitut_plugin.htm",l:-1,t:"3.2 uiTut plugin",i:0.0161290322580645,a:"In uiTut , the GUI consists of two parts. One deals with opening an independent dialog box via a menu item in the \u0027Utilities\u0027 menu. The other part gets the \u0027Tutorial\u0027 attribute listed in the \u0027Edit Attributes\u0027 dialog and creates the input fields in the same dialog box. It also sends the input ..."},"21":{y:0,u:"../content/3_the_tutorial_plugin/3_3_tut_plugin.htm",l:-1,t:"3.3 Tut plugin",i:0.0161290322580645,a:"The responsibility of uiTut is limited to talking to the user and getting the input parameters. The real work is done behind the scene by the non-UI Tut plugin. And that is the reason why it is of type EARLY. This particular plugin tells OpendTect\u0027s application manager that it wants to be loaded ..."},"22":{y:0,u:"../content/3_the_tutorial_plugin/3_4_seistools.htm",l:-1,t:"3.4 SeisTools",i:0.0161290322580645,a:"Let us first look at the direct seismic operations, that are handled by the class SeisTools, which in turn is a subclass of class Executor. \u0027Real work\u0027 is done by the function nextStep() which is typical of class Executor. Here, three different operations are possible: Scaling, where you can ..."},"23":{y:0,u:"../content/3_the_tutorial_plugin/3_5_hortool.htm",l:-1,t:"3.5 HorTool",i:0.0161290322580645,a:"Similar to SeisTools, HorTool performs some simple operations on horizons: thickness computation and smoothening. Each of these operations is handled by a subclass of HorTool which is a subclass of Executor and as expected the computation is performed by the function nextStep(). You may notice here ..."},"24":{y:0,u:"../content/3_the_tutorial_plugin/3_6_the_tutorial_attribute.htm",l:-1,t:"3.6 The Tutorial Attribute",i:0.0161290322580645,a:"We have seen the direct seismic approach to simple operations on seismic data in SeisTools. For our purpose, it suits well. But the main problem with this approach is the difficulty in multi-trace handling. Moreover, for large seismic volumes, handling each trace one-by-one may slow down the ..."},"25":{y:0,u:"../content/3_the_tutorial_plugin/3_7_steering.htm",l:-1,t:"3.7 Steering",i:0.0161290322580645,a:"A Steering cube, as the name suggests, works as a guiding cube. It stores the Inline dip and Crossline dip at each point, which guides the attribute engine in multi-trace computations. In case of our Tutorial attribute, we can use the steering data for horizontal smoothening. The key function is ..."},"26":{y:0,u:"../content/4_build_opendtect_from_source.htm",l:-1,t:"4 Build OpendTect from source",i:0.0161290322580645,a:"4 Build OpendTect from source"},"27":{y:0,u:"../content/4_build_opendtect_from_source/4_1_introduction.htm",l:-1,t:"4.1 Introduction",i:0.0161290322580645,a:"  This section lays out a step by step setup of a standard build environment on Windows 10, MacOS and Linux. Using a different setup might be possible, but probably requires extra work. Requirements A C++ compiler and compilation tool chain: Windows: msvc2017 64 bit. The free community edition is ..."},"28":{y:0,u:"../content/4_build_opendtect_from_source/4_2_setting_up_the_environment.htm",l:-1,t:"4.2 Setting up the environment",i:0.0161290322580645,a:"4.2  Setting up the environment To build OpendTect from source you need to pull the source code from https://github.com/OpendTect/OpendTect. Then build the solution with CMake. In this case launch CMake and browse to your OpendTect source folder and start configuring and generating from CMake. CMake ..."},"29":{y:0,u:"../content/4_build_opendtect_from_source/4_3_building_opendtect.htm",l:-1,t:"4.3 Building OpendTect",i:0.0161290322580645,a:"4.3 Building OpendTect"},"30":{y:0,u:"../content/5_contributing_to_the_source_code.htm",l:-1,t:"5 Contributing to the Source Code",i:0.0161290322580645,a:"5 Contributing to the Source Code"},"31":{y:0,u:"../content/5_structure_of_the_source_code/5_1_introduction.htm",l:-1,t:"5.1 Introduction",i:0.0161290322580645,a:"The repository contains a number of release branches and 3 development branches. The current stable release branch is 6.4.4 The development branches are: BRANCH\tDESCRIPTION master This is the bleeding edge where migration of OpendTect to new versions of its major dependencies, Qt and OpenSceneGraph, ..."},"32":{y:0,u:"../content/5_structure_of_the_source_code/5_2_design_principles.htm",l:-1,t:"5.2 Design principles",i:0.0161290322580645,a:"There are many aspects of software that can be categorised as \u0027good\u0027. These include robustness, flexibility, high performance, compactness, maintainability, understandability. Software engineering is all about making choices - every aspect costs resources and there\u0027s always a limit to that. So, even ..."},"33":{y:0,u:"../content/5_structure_of_the_source_code/5_3_isolation_of_external_services.htm",l:-1,t:"5.3 Isolation of external services",i:0.0161290322580645,a:"When services from another package (Qt, OpenSceneGraph, ...) are used, there is always an isolating layer - either a complete module or a class that uniquely uses those services. For software engineers this is an obvious action were it only to reduce the dependency problems. There is however more to ..."},"34":{y:0,u:"../content/5_structure_of_the_source_code/5_4_modules.htm",l:-1,t:"5.4 Modules",i:0.0161290322580645,a:"5.4 Modules"},"35":{y:0,u:"../content/5_structure_of_the_source_code/5_4_modules/5_4_1_intro.htm",l:-1,t:"5.4.1 Introduction",i:0.0161290322580645,a:"A group of classes that handle a certain area of our domain is what could be called a module. Sometimes these modules have their own namespace, most often not (sometimes because the code pre-dates good support of namespaces by gcc). In any case, it does correspond with two physical directories in ..."},"36":{y:0,u:"../content/5_structure_of_the_source_code/5_4_modules/5_4_2_the_separation.htm",l:-1,t:"5.4.2 The separation",i:0.0161290322580645,a:"The separation of include and src is first of all a visibility issue. The include files can be \u0027seen\u0027 by other modules, the src files not. Conceptually, the separation is roughly interface versus implementation. Roughly, because small functions are often implemented in the header file. Another ..."},"37":{y:0,u:"../content/5_structure_of_the_source_code/5_4_modules/5_4_3_rw_modules.htm",l:-1,t:"5.4.3 RW modules",i:0.0161290322580645,a:"First of all, there are the Basic, Algo and General modules. General depends on Algo, which in turn depends on Basic. The separation is a bit arbitrary, and the idea was that Basic would be tools also usable outside OpendTect. It\u0027s easy to find a counterexample like survinfo which was placed there ..."},"38":{y:0,u:"../content/5_structure_of_the_source_code/5_4_modules/5_4_4_ui_modules.htm",l:-1,t:"5.4.4 UI modules",i:0.0161290322580645,a:"For most of the RW-modules, there is a UI counterpart. This is made possible by the basic UI modules uiBase, uiTools and uiIo, the basic 3D visualisation module visBase and the basic combined stuff in uiOSG. On top of everything is the UI application logic in uiODMain. The uiBase module is one of ..."},"39":{y:0,u:"../content/5_structure_of_the_source_code/5_5_contributing.htm",l:-1,t:"5.5 Contributing",i:0.0161290322580645,a:"You can contribute to the enhancement of OpendTect either by: •\tproviding bug fixes or enhancements to the OpendTect source code following the usual Github Fork-Pull Request process. •\tor independently by developing and releasing open source plugins from your own Github or equivalent repository. See ..."},"40":{y:0,u:"../content/6_principles_and_best_practices_in_opendtect_coding.htm",l:-1,t:"6 Principles and best practices in OpendTect coding",i:0.0161290322580645,a:"6 Principles and best practices in OpendTect coding"},"41":{y:0,u:"../content/6_principles_and_best_practices_in_opendtect_coding/6_1_introduction.htm",l:-1,t:"6.1 Introduction",i:0.0161290322580645,a:"Software engineering is a game of trade-offs. Performance vs generality, flexibility vs stability, priorities vs general goals, and so on, and so on. A good software engineer weighs all pros and cons and comes up with (near-)optimal solutions, often trying to get the best of everything. Of course, ..."},"42":{y:0,u:"../content/6_principles_and_best_practices_in_opendtect_coding/6_2_requirements.htm",l:-1,t:"6.2 Requirements",i:0.0161290322580645,a:"6.2 Requirements"},"43":{y:0,u:"../content/6_principles_and_best_practices_in_opendtect_coding/6_2_requirements/6_2_1_nice_and_neat.htm",l:-1,t:"6.2.1 Nice and neat",i:0.0161290322580645,a:"Good code should look good. You have to find joy in making the things you deliver look as good as (reasonably) possible, and as easy to understand as possible. Compare these two class definitions: class SizeKeeper { public:                  SizeKeeper() : sz_(0)\t        \t{} ..."},"44":{y:0,u:"../content/6_principles_and_best_practices_in_opendtect_coding/6_2_requirements/6_2_2_uniform.htm",l:-1,t:"6.2.2 Uniform",i:0.0161290322580645,a:"This is not a point to be taken lightly. Other team members will at some point have to change your code, other team members will at some point have to debug your code. Uniformity makes sure this is as easy as possible. Remember this: changing code you haven\u0027t made yourself is never easy, so do ..."},"45":{y:0,u:"../content/6_principles_and_best_practices_in_opendtect_coding/6_2_requirements/6_2_3_simple_and_easy.htm",l:-1,t:"6.2.3 Simple and Easy",i:0.0161290322580645,a:"Any complex process can be broken up into simple steps, any complex object can be broken up into simple objects. Always consider yourself as publishing something that needs to be read by others. Take them by the hand and make it easy to understand what you are doing, and why you are doing it. Avoid ..."},"46":{y:0,u:"../content/6_principles_and_best_practices_in_opendtect_coding/6_3_explicit_rules.htm",l:-1,t:"6.3 Explicit Rules",i:0.0161290322580645,a:"6.3 Explicit Rules"},"47":{y:0,u:"../content/6_principles_and_best_practices_in_opendtect_coding/6_3_explicit_rules/6_3_1_introduction.htm",l:-1,t:"6.3.1 Introduction",i:0.0161290322580645,a:"The way we do things in OpendTect is not a 100% fixed body of rules. Moreover, we tend to say \u0027rather do this than that\u0027, or sometimes we change our point of view. Still, we almost unanimously agree on almost every issue. To lower the time to discover how we do things, next to going through lots of ..."},"48":{y:0,u:"../content/6_principles_and_best_practices_in_opendtect_coding/6_3_explicit_rules/6_3_2_oo_and_general_rules.htm",l:-1,t:"6.3.2 OO and general rules",i:0.0161290322580645,a:"•\tTry to avoid pure implementation inheritance. Inheritance of \u0027mainly interface\u0027 is usually OK. In all cases, ask yourself whether there really is a \u0027isA\u0027 relation between the classes. Prefer delegation in any doubt. •\tBe very aware of dependency management. Avoid using services from classes that ..."},"49":{y:0,u:"../content/6_principles_and_best_practices_in_opendtect_coding/6_3_explicit_rules/6_3_3_c++_rules.htm",l:-1,t:"6.3.3 C++ rules",i:0.0161290322580645,a:"•\tWe do not use exceptions. Exceptions are the horror story of C++, try looking at C++ report, November-December 1994, Tom Cargill: \"Exception handling: A false sense of security\". There are more reasons, for example that you have to use a certain paradigm throughout: RAII (Not a bad principle but ..."},"50":{y:0,u:"../content/6_principles_and_best_practices_in_opendtect_coding/6_4_semantical_rules.htm",l:-1,t:"6.4 Semantical/typographical rules",i:0.0161290322580645,a:"First of all: the naming of classes, variables, namespaces, etc. is extremely important. You want to optimise understandability and compactness, in doubt always go for understandability. Naming should be as intuitive as possible. If you cannot find an intuitive name, consider the possibility that ..."},"51":{y:0,u:"../content/6_principles_and_best_practices_in_opendtect_coding/6_5_layout.htm",l:-1,t:"6.5 Layout",i:0.0161290322580645,a:"No other subject brings up this many discussions. While it\u0027s simple: choose a policy and stick to it. The end result is what counts: readability, compactness, understandability. Thus all rules can be broken if it really helps those properties, but they rarely are. •\tIndentation: 4 spaces per level, ..."},"52":{y:0,u:"../content/6_principles_and_best_practices_in_opendtect_coding/6_6_adapting_code.htm",l:-1,t:"6.6 Adapting code",i:0.0161290322580645,a:"From now on, new code will be as described above. What to do if the code you\u0027re changing is not good according to these standards? That depends on the amount of work vs the amount of time vs the importance of the deviation. The rules are: •\tMake sure the code is, after you\u0027re done with it, ..."},"53":{y:0,u:"../content/7_class_documentation_and_other_resources.htm",l:-1,t:"7 Class Documentation and other resources",i:0.0161290322580645,a:"7 Class Documentation and other resources OpendTect Class Documentation odpy Documentation"},"54":{y:0,u:"../content/glossary.htm",l:-1,t:"Glossary",i:0.0161290322580645,a:"Glossary"},"55":{y:0,u:"../content/html_front_page/od_userdoc_v6.htm",l:-1,t:"OpendTect User Documentation - 6.6",i:0.0161290322580645,a:"Copyright © 2002-2019 by dGB Beheer B.V. All rights reserved. No part of this publication may be reproduced and/or published by print, photo print, microfilm or any other means without the written consent of dGB Beheer B.V. Under the terms and conditions of any of the following three license types, ..."},"56":{y:0,u:"../content/preface/about_opendtect.htm",l:-1,t:"1.3 About OpendTect",i:0.0161290322580645,a:"The OpendTect suite of software products consists two parts: an open source part and a closed source part. The open source part is called OpendTect. This is a seismic interpretation software system for post-processing, visualizing and interpreting multi-volume seismic data, and for fast-track ..."},"57":{y:0,u:"../content/preface/release_notes.htm",l:-1,t:"1.2 Release Notes",i:0.0161290322580645,a:"This is the user documentation for release OpendTect v6.4 - an open source post-processing, and seismic interpretation system created by  dGB Earth Sciences . OpendTect is released via the internet. Users can download the software from the  dGB website . It will run without license protection. ..."},"58":{y:0,u:"../content/preface/copyright.htm",l:-1,t:"1.4 Copyright",i:0.0161290322580645,a:"The information contained in this manual and the accompanying software programs are copyrighted and all rights reserved by  dGB Beheer BV, hereinafter dGB. dGB reserves the right to make periodic modifications to this product without obligation to notify any person or entity of such revision. ..."},"59":{y:0,u:"../content/preface/about_this_manual.htm",l:-1,t:"1.1 About this Manual",i:0.0161290322580645,a:"This manual is the user documentation of the open source part of the OpendTect seismic interpretation system. In this document detailed information on windows and parameter settings are described. The lay-out follows the organization of the software menus. Information about attributes and filters is ..."},"60":{y:0,u:"../content/preface/acknowledgements.htm",l:-1,t:"1.5 Acknowledgements",i:0.0161290322580645,a:"The OpendTect system is developed around concepts and ideas originating from a long-term collaboration between dGB and Statoil. Most of the system was and is developed through sponsored projects. We are indebted to all past, present and future sponsors. To name a few: Addax ARKCLS BG Group Chevron ..."},"61":{y:0,u:"../content/preface.htm",l:-1,t:"1 Preface",i:0.0161290322580645,a:"1 Preface"},});