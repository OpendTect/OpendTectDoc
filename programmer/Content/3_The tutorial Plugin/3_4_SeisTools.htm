<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd">
    <head>
    </head>
    <body>
        <h2>3.4 SeisTools<MadCap:concept term="SeisTools" /></h2>
        <p>Let us first look at the direct seismic operations, that are handled by the class <span style="font-family: monospace;">SeisTools</span>, which in turn is a subclass of class Executor. 'Real work' is done by the function <span style="font-family: monospace;">nextStep()</span> which is typical of class Executor. Here, three different operations are possible: Scaling, where you can multiply the data values by a certain factor and apply a shift; Squaring, where, as the name suggests, you can take a square of the data values; and Smoothening, where you can take the arithmetic average of 3 or 5 samples depending on the filter strength. Traces are read one-by-one by a <span style="font-family: monospace;">SeisTrcReader</span> and supplied to the function <span style="font-family: monospace;">handleTrace()</span> where the actual computation is done. Then a <span style="font-family: monospace;">SeisTrcWriter</span> writes the output traces one-by-one to the output cube.</p>
        <p style="font-family: monospace;text-align: left;">int Tut::SeisTools::nextStep()<br />{<br />&#160;&#160;&#160;&#160;if ( !rdr_ )<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return createReader() ? Executor::MoreToDo()<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;: Executor::ErrorOccurred();<br /><br />&#160;&#160;&#160;&#160;int rv = rdr_-&gt;get( trcin_.info() );<br />&#160;&#160;&#160;&#160;if ( rv &lt; 0 )<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{ errmsg_ = rdr_-&gt;errMsg(); return Executor::ErrorOccurred(); }<br />&#160;&#160;&#160;&#160;else if ( rv == 0 )<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return Executor::Finished();<br />&#160;&#160;&#160;&#160;else if ( rv == 1 )<br />&#160;&#160;&#160;&#160;{<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if ( !rdr_-&gt;get(trcin_) )<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{ errmsg_ = rdr_-&gt;errMsg(); return Executor::ErrorOccurred(); }<br /><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;trcout_ = trcin_;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;handleTrace();<br /><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if ( !wrr_ &amp;&amp; !createWriter() )<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return Executor::ErrorOccurred();<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if ( !wrr_-&gt;put(trcout_) )<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{ errmsg_ = wrr_-&gt;errMsg(); return Executor::ErrorOccurred(); }<br />&#160;&#160;&#160;&#160;}<br /><br />&#160;&#160;&#160;&#160;return Executor::MoreToDo();<br />}</p>
        <p>Scaling and squaring are single-sample operations. But as you can see in the implementation of the function <span style="font-family: monospace;">handleTrace()</span> below, smoothening involves multi-sample computation. It requires separate input and output traces. Otherwise, if we did the operation on the same trace, we would be taking the modified values of samples preceding the current sample. For the sake of simplicity, we make a copy of the input trace to store the output values. This is not a good practice as it results in duplication of data. But since it is a tutorial, our aim is to keep the code as simple as possible and leave the efficiency part for serious programming.</p>
        <p style="font-family: monospace;text-align: left;">void Tut::SeisTools::handleTrace()<br />{<br />&#160;&#160;&#160;&#160;switch ( action_ )<br />&#160;&#160;&#160;&#160;{<br /><br />&#160;&#160;&#160;&#160;case Scale: {<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;SeisTrcPropChg stpc( trcout_ );<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;stpc.scale( factor_, shift_ );<br />&#160;&#160;&#160;&#160;} break;<br /><br />&#160;&#160;&#160;&#160;case Square: {<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for ( int icomp=0; icomp &lt; trcin_.nrComponents(); icomp++ )<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for ( int idx=0; idx &lt; trcin_.size(); idx++ )<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const float v = trcin_.get( idx, icomp );<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;trcout_.set( idx, v*v, icomp );<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br />&#160;&#160;&#160;&#160;} break;<br /><br />&#160;&#160;&#160;&#160;case Smooth: {<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const int sgate = weaksmooth_ ? 3 : 5;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const int sgate2 = sgate/2;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for ( int icomp=0; icomp &lt; trcin_.nrComponents(); icomp++ )<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for ( int idx=0; idx &lt; trcin_.size(); idx++ )<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;float sum = 0;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int count = 0;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for( int ismp=idx-sgate2; ismp &lt;= idx+sgate2; ismp++)<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const float val = trcin_.get( ismp, icomp );<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if ( !mIsUdf(val) )<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sum += val;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;count++;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if ( count )<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;trcout_.set( idx, sum/count, icomp );<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br />&#160;&#160;&#160;&#160;} break;<br />}<br />nrdone_++;<br />}</p>
    </body>
</html>