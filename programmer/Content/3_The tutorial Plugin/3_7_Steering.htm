<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd">
    <head>
    </head>
    <body>
        <h2>3.7 Steering<MadCap:concept term="Steering" /></h2>
        <p>A Steering cube, as the name suggests, works as a guiding cube. It stores the Inline dip and Crossline dip at each point, which guides the attribute engine in multi-trace computations. In case of our Tutorial attribute, we can use the steering data for horizontal smoothening. The key function is <span style="font-family: monospace;">initSteering()</span> which makes the steering data available in the form of shifts relative to the central trace. To understand how this shift is used during computation, please refer to the horizontal smoothening section in the function <span style="font-family: monospace;">computeData()</span>.</p>
        <p>Some fundamental attribute functions are listed here:</p>
        <p><span style="font-family: monospace;">createInstance()</span>
        </p>
        <p>This function is standard for every attribute, here is the attribute constructor called. Use the macro <span style="font-family: monospace;">mAttrDefCreateInstance</span> to define <span style="font-family: monospace;">createInstance</span>:</p>
        <p style="font-family: monospace;">mAttrDefCreateInstance(Tutorial)</p>
        <p style="font-family: monospace;">initClass()</p>
        <p>This static function initializes the attribute: sets up the parameters and the number and type of the inputs and outputs. You can compare this to what you see in Opendtect in the attribute definition window after loading the <span style="font-family: monospace;">uiTut</span> plugin.</p>
        <p>If you look at the parts of the implementation carefully, ( tutorialattrib.cc ) you'll see that each parameter is built up following this example:</p>
        <p style="font-family: monospace;text-align: left;">EnumParam* action = new EnumParam( actionStr() );<br />&#160;&#160;&#160;&#160;action-&gt;addEnum( "Scale" );<br />&#160;&#160;&#160;&#160;action-&gt;addEnum( "Square" );<br />&#160;&#160;&#160;&#160;action-&gt;addEnum( "Smooth" );<br />&#160;&#160;&#160;&#160;desc-&gt;addParam( action );</p>
        <p>Every parameter is required by default, to overrule this use <span style="font-family: monospace;">setRequired(false)</span></p>
        <p><span style="font-family: monospace;">initClass()</span> also adds the attribute to the attribute factory. In this case, as every attribute is a provider, the Tutorial attribute is added to PF() (the <span style="font-family: monospace;"><a href="../../Generated/html/classAttrib_1_1ProviderFactory.html">Attrib::ProviderFactory</a></span> singleton access function).</p>
        <p><span style="font-family: monospace; font-weight: bold;">updateDesc()</span>
        </p>
        <p>Will be used not only to update the parameters but also the number and type of the outputs and to add or disable some inputs. If you look at the implementation for the tutorial attribute, this function just allows to enable or disable the inputs ( factor, shift and smooth ) according to the action chosen by the user</p>
        <p><span style="font-family: monospace; font-weight: bold;">getInputOutput()</span>
        </p>
        <p>we need to define this initialization function because we have Steering. Steering always carries two outputs and we need them both.</p>
        <p><span style="font-family: monospace; font-weight: bold;">initSteering()</span>
        </p>
        <p>If we are using steering data, this function prepares the steering input for use in computation. A subvolume is generated around the central trace, with the size of the subvolume specified by the stepout. This data contains the shifts in terms of number of samples for each trace in the subvolume relative to the central trace.</p>
        <p style="font-family: monospace;text-align: left;">void Tutorial::initSteering()<br />{<br />&#160;&#160;&#160;&#160;if ( inputs[1] &amp;&amp; inputs[1]-&gt;getDesc().isSteering() )<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;inputs[1]-&gt;initSteering( stepout_ );<br />}</p>
        <p style="font-family: monospace;"><b>getInputData()</b>
        </p>
        <p>Before the work can be done, some input has to be given. This function is the place where you specify how to get your input data. For the Tutorial this is the seismic data. But it can also be Steering Data or any other attribute.</p>
        <p style="font-family: monospace;text-align: left;">bool Tutorial::getInputData( const BinID&amp; relpos, int zintv )<br />{<br />&#160;&#160;&#160;&#160;if ( inpdata_.isEmpty() )<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;inpdata_ += 0;<br />&#160;&#160;&#160;&#160;const DataHolder* data = inputs[0]-&gt;getData( relpos, zintv );<br />&#160;&#160;&#160;&#160;if ( !data ) return false;<br />&#160;&#160;&#160;&#160;inpdata_.replace( 0, data);<br /><br />&#160;&#160;&#160;&#160;if ( action_ ==2 &amp;&amp; horsmooth_ )<br />&#160;&#160;&#160;&#160;{<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;steeringdata_ = inputs[1] ? inputs[1]-&gt;getData( relpos, zintv ) : 0;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const int maxlength  = mMAX(stepout_.inl, stepout_.crl)*2 + 1;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while ( inpdata_.size() &lt; maxlength * maxlength )<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;inpdata_ += 0;<br /><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for ( int idx=0; idxgetData( relpos + posandsteeridx_.pos_[idx] );<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if ( !data ) continue;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;inpdata_.replace( posandsteeridx_.steeridx_[idx], data);<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br />&#160;&#160;&#160;&#160;}<br /><br />&#160;&#160;&#160;&#160;dataidx_ = getDataIndex( 0 );<br /><br />&#160;&#160;&#160;&#160;return true;<br /><br />}</p>
        <p>You will notice from here that the calculation of the attributes is not done on traces but using a different object, the <span style="font-family: monospace;">DataHolder</span>. The dataholder contains a set of <span style="font-family: monospace;"><a href="../../Generated/html/classValueSeries.html" target="_parent">ValueSeries</a></span> which holds the value of every sample of the <span style="font-family: monospace;">SeisTrc</span>. Advantage: in case of an attribute which has other attributes as inputs, data is available in the corresponding dataholders, it thus saves a lot of time ( easier and much faster to read some floats in a <span style="font-family: monospace;">ValueSeries</span> than to get values from a <span style="font-family: monospace;">SeisTrc</span> ). Stored data are read from cubes of seismic traces and written the same way.</p>
        <p>The <span style="font-family: monospace;">DataHolder</span> is also carrying some specific information about the trace to be processed, like the start sample number and the number of samples you wish to calculate.</p>
        <p>Another important remark: calculation is made using sample numbers, not time or depth</p>
        <p>Most of the rest of the methods are there to comply with the <span style="font-family: monospace;">Attrib::Provider</span> interface - see the <span style="font-family: monospace;"><a href="../../Generated/html/classAttrib_1_1Provider.html" target="_parent">Attrib::Provider</a></span> documentation. The basic idea is that for each sample of each trace one or more attribute values can be calculated. The number of attribute values (or outputs) is defined in the <span style="font-family: monospace;">initClass()</span> function. If your input requires additional samples (timegate) or neighbouring traces (stepout), you will have to define <span style="font-family: monospace;">reqZMargin()</span> and <span style="font-family: monospace;">reqStepout()</span> respectively.</p>
        <p><span style="font-family: monospace;font-weight: bold;">computeData()</span>
        </p>
        <p>When we want to look at the actual work, the place to be is the <span style="font-family: monospace;">computeData()</span> method. This is the place where you define the mathematics for calculating the attribute. This function is called for each trace of your output cube.</p>
        <p>In the <span style="font-family: monospace;">computeData()</span> method, we are faced with a number of Z ranges. To be able to support multi-threading, <span style="font-family: monospace;">computeData</span> must be ready to only process part of the trace. Then, also, we can have input cubes that are larger than requested or desired, or smaller than that. This delivers a rather nasty picture of Z indexes that we really cannot circumvent. To make things at least clear, the indexes are all related to the the absolute Z=0. This is where everything refers to. Then, we have different start Z indexes for each of the input cubes and the output cube. These are named 'z0_' in the corresponding DataHolders.</p>
        <p>
            <img src="../Resources/Images/fig_explainz0.png" MadCap:mediastyle="@media print { max-width: 100%; }" style="max-width: 100%;" />
        </p>
        <p>Let us have a look at the <span style="font-family: monospace;">Tutorial::computeData</span> function and compare it with the code in <span style="font-family: monospace;">SeisTools</span>. The algorithm for actual computation is the same in both the cases, but there is a marked difference in the manner in which seismic data is accessed in each case.</p>
        <p style="font-family: monospace;text-align: left;">bool Tutorial::computeData( const DataHolder&amp; output, const BinID&amp; relpos,<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int z0, int nrsamples, int threadid ) const<br />{<br />&#160;&#160;&#160;&#160;for ( int idx=0; idx &lt; nrsamples; idx++ )<br />&#160;&#160;&#160;&#160;{<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;float outval = 0;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if ( action_==0 || action_==1 )<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const float trcval = getInputValue( *inputdata_, dataidx_,<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;idx, z0 );<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;outval = action_==0 ? trcval * factor_ + shift_ :<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;trcval * trcval;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else if ( action_==2 &amp;&amp; !horsmooth_ )<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;float sum = 0;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int count = 0;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for ( int isamp=sampgate_.start; isamp &lt;= sampgate_.stop; isamp++ )<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const float curval = getInputValue( *inpdata_[0], dataidx_,<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;idx + isamp, z0 );<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if ( !mIsUdf(curval) )<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sum += curval;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;count ++;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;outval = sum / count;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else if (action_ == 2 &amp;&amp; horsmooth_ )<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;float sum = 0;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int count = 0;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for ( int posidx=0; posidx &lt; inpdata_.size(); posidx++ )<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if ( !inpdata_[posidx] ) continue;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const float shift = steeringdata_ ?<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;getInputValue( *steeringdata_,posidx, idx, z0 ) : 0;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const int sampidx = idx + ( mIsUdf(shift) ? 0 : mNINT(shift) );<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if ( sampidx &lt; 0 || sampidx &gt;= nrsamples ) continue;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const float val = getInputValue( *inpdata_[posidx],<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;dataidx_, sampidx, z0 );<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if ( !mIsUdf(val) )<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sum += val;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;count ++;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;outval = sum / count;<br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br /><br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;setOutputValue( output, 0, idx, z0, outval );<br />&#160;&#160;&#160;&#160;}<br /><br />&#160;&#160;&#160;&#160;return true;<br /><br />}</p>
    </body>
</html>